<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thebesttv&#39;s blog</title>
  
  <subtitle>Think twice, then code once.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thebesttv.github.io/"/>
  <updated>2019-08-04T13:35:11.881Z</updated>
  <id>https://thebesttv.github.io/</id>
  
  <author>
    <name>thebesttv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[UVa 11729] Commando War</title>
    <link href="https://thebesttv.github.io/2019/07/01/UVA_11729_Commando_War/"/>
    <id>https://thebesttv.github.io/2019/07/01/UVA_11729_Commando_War/</id>
    <published>2019-07-01T12:55:00.000Z</published>
    <updated>2019-08-04T13:35:11.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个士兵，让他们干活。对于每个士兵 i ，交代任务时间为 $B_i$ ，然后他执行任务的时间为 $J_i$。一个个给他们下达命令，求最小总时间</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>贪心：将所有士兵按照 $j$ 排序，然后一个个下达命令即可。<br>汝佳的书上基本已经写清楚了，但我一开始还是不太理解为什么要交换“相邻”元素，后来想到冒泡排序。冒泡排序能把任意数列排到有序，那它的逆过程就能把一个有序序列变成任意序列。再扩展一下，只需多次相邻两两交换就可得到任意序列。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, kase=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ind</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ind &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; i.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ind[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line">    FOR(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ind[i].a, &amp;ind[i].b);</span><br><span class="line">    sort(ind, ind+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,sa=<span class="number">0</span>;</span><br><span class="line">    FOR(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">      sa += ind[i].a;</span><br><span class="line">      ans = max(ans, sa + ind[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,++kase,ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定 n 个士兵，让他们干活。对于每个士兵 i ，交代任务时间为 $B_i$ ，然后他执行任务的时间为 $J_i$。一个个给他们下达命令，求最小总时间&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>even if, even though, even as, even so</title>
    <link href="https://thebesttv.github.io/2019/02/02/even_if_even_though_even_as_even_so/"/>
    <id>https://thebesttv.github.io/2019/02/02/even_if_even_though_even_as_even_so/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-08-04T13:34:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>这几个词连起来都可以当成歌来唱了……</p><a id="more"></a><h1 id="even-as"><a href="#even-as" class="headerlink" title="even as"></a>even as</h1><p>even：at the very time</p><img src="/2019/02/02/even_if_even_though_even_as_even_so/1.jpg"><p>even as: exactly at the same time</p><blockquote><p>Even as she said this, she knew it was not quite true.<br>Even as I warned her, she slipped.</p></blockquote><h1 id="even-so"><a href="#even-so" class="headerlink" title="even so"></a>even so</h1><p>so 相当于代词，指代上文所提及的情况。even so 具有副词性质，不用作连词。</p><blockquote><p>The bus was only half full. Even so, a young man asked Nina if the seat next to her was taken.<br>There’re many spelling mistakes; even so, it’s quite a good essay.<br>It was cold, but even so we enjoyed the garden party.</p></blockquote><h1 id="重头戏：even-if-even-though"><a href="#重头戏：even-if-even-though" class="headerlink" title="重头戏：even if, even though"></a>重头戏：even if, even though</h1><p>even if &amp; even though 的本质，就是 if 和 though 被 even(ad.) 修饰（暂时这两个even的意思还不明白）。而 if 和 though 在此都为连词，那么这两个词组也就具有了连词的性质。<br>两个词的区别类似于“虽”的两个意思——虽然（表事实的让步）、即使（表假设的让步）</p><h2 id="even-though——强调事实的让步：虽然"><a href="#even-though——强调事实的让步：虽然" class="headerlink" title="even though——强调事实的让步：虽然"></a>even though——强调事实的让步：虽然</h2><blockquote><p>Even though means <em>despite the fact that</em> and is <strong>a more emphatic version of though and although</strong>.</p></blockquote><p>even though 表示的一定是事实</p><blockquote><p>I like her, even though she can be annoying at times.<br>“她有时可能烦人”是一个事实，但这不妨碍我喜欢她。</p></blockquote><blockquote><p>Even though he was bigger, he never looked down on me.</p></blockquote><h2 id="even-if——不强调事实的让步"><a href="#even-if——不强调事实的让步" class="headerlink" title="even if——不强调事实的让步"></a>even if——<em>不强调</em>事实的让步</h2><blockquote><p>even if: regardless of whether; irrespective of (something happening or being the case).</p></blockquote><p>even if 可以表示<em>假设的让步</em>（hypothesis；即使），但其所说的也可以是事实，不过说话者不强调它是事实。</p><blockquote><p>He is a great President, even if he has many enemies. 尽管他有许多敌人，他仍不失为是一位伟大的总统。<br>在此句中，他有敌人是一个事实，但说话者并不强调这一点（无论是与“他是否有敌人”还是与主句之间）</p></blockquote><blockquote><p>Even if you have perfect vision, you should still have your eyes checked regularly.<br>无论你是否有1.0的视力，都要去检查。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>Even if I had two hours to spare for shopping, I wouldn’t go out and buy a suit.<br>Even though I had two hours to spare for shopping, I couldn’t find the suit I wanted.</p><p>Even though he lost his job as Arts Minister, he continued to serve in the government.<br>Even if he loses his job as Arts Minister, I think he’ll continue to serve in the government.</p><p>Even though the injury was serious, she decided to carry on playing. It was an important match.<br>I know she’ll want to carry on playing, even if she gets injured. It’s an important match.</p><p>Even though I’ve cleaned it and polished it, it still doesn’t look new.<br>Even if I clean and polish it, it still won’t look new.</p><p>ps. 还是<a href="http://www.bbc.co.uk/worldservice/learningenglish/youmeus/learnit/learnitv122.shtml" target="_blank" rel="noopener">BBC的那个网站</a>讲得好……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几个词连起来都可以当成歌来唱了……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019/02/01 英语卡片</title>
    <link href="https://thebesttv.github.io/2019/02/01/English_card/"/>
    <id>https://thebesttv.github.io/2019/02/01/English_card/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-08-04T13:34:29.517Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有把一张英语卡片标注成这样了……</p><a id="more"></a><img src="/2019/02/01/English_card/card.jpg" title="the card">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有把一张英语卡片标注成这样了……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vasily Tsibliyev</title>
    <link href="https://thebesttv.github.io/2019/01/29/Vasily_Tsibliyev/"/>
    <id>https://thebesttv.github.io/2019/01/29/Vasily_Tsibliyev/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-08-04T13:35:21.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Tsibliyev.jpg/220px-Tsibliyev.jpg" alt="Vasily Tsibliyev"></p><a id="more"></a><p>今天看了《读写快易通（一）》的第四章，里面是一篇 Times 的关于俄罗斯宇航员 Vasily Tsibliyev 的报道。一开始看文章没太大感觉，不过里面有几道题不太会，然后就查了一下他的报道，然后就看到了另一篇 <a href="http://content.time.com/time/magazine/article/0,9171,138231,00.html" target="_blank" rel="noopener">Life After Mir</a> ，01年的，可能是他回到地球后的生活吧。感觉这篇文章全文都比较 gloomy。<br>一个宇航员，本应该被尊重，但因为几个过失（可能都不是他的错），就变得这样……<br>可能我没看懂文章，不过感觉还是挺悲伤的。</p><p>之后如果能多了解一下他，可能会来更新吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Tsibliyev.jpg/220px-Tsibliyev.jpg&quot; alt=&quot;Vasily Tsibliyev&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>寒假之间</title>
    <link href="https://thebesttv.github.io/2019/01/29/%E5%AF%92%E5%81%87%E4%B9%8B%E9%97%B4/"/>
    <id>https://thebesttv.github.io/2019/01/29/寒假之间/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-08-04T13:35:48.821Z</updated>
    
    <content type="html"><![CDATA[<p>暂时有点不想干什么，随便写点抒发一下感慨……</p><a id="more"></a><p>这个寒假会过得很快很快，每天会有很多事做不完，不想做，然而还得继续做。</p><p>刚刚一篇文章的 summary，被 GR 的惊艳了一脸……我可能八辈子都不会用那么厉害的词，都没法归纳得那么精辟了…… emm, like a huge knock on my self-esteem? I don’t know, maybe.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时有点不想干什么，随便写点抒发一下感慨……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>New Year 2019 — transition</title>
    <link href="https://thebesttv.github.io/2019/01/01/NewYear_2019/"/>
    <id>https://thebesttv.github.io/2019/01/01/NewYear_2019/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-08-04T14:05:23.806Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/01/NewYear_2019/1.jpg" title="New Year 2019"><p>So what is new year?<br>It’s a time for reflection: all you’ve done in the past year — all the achievements you’ve made, all the failures you’ve experienced, all the setbacks you’ve conquered; and all the sweetness you’ve enjoyed, all the bitterness you’ve tasted, something one can call “bittersweet”.<br>But it goes far beyond that. It’s the end of this year, but the starting point of a whole new one, one that you can hope for, one that you can have the wildest imagination about. The year 2019 is a year full of possibilities, and of course, for me, full of tests &amp; scores &amp; mistakes &amp; corrections. And the most important, 高考。</p><a id="more"></a><p>（没想到看看别人说说就看到2019年了，挺欢乐的哈）</p><h1 id="overall"><a href="#overall" class="headerlink" title="overall"></a>overall</h1><p>这是一个从 OI 到文化课的一年——这是我暂时最好的总结，毕竟太多发生了，太多改变了。</p><h1 id="look-backward"><a href="#look-backward" class="headerlink" title="look backward"></a>look backward</h1><p>就按时间顺序说吧。</p><p>年初的时候我还在准备冬令营，恰逢大雪，期末考试延期，于是几天都待在文德楼。不去评说那段时间有多少成效（毕竟我也不知道），至少还挺温馨的吧。<br>记得去冬令营的前一天晚上，我又出去走了一圈，走得挺远。看一下那天的日记，发现我在思考 活着的意义 ，emm……，现在想想可能就像史铁生说的，用不着思考吧。走之前托 GR 帮我把各种讲义整理一下，她也的确很认真地帮我弄了。<br>其实冬令营那几天挺孤独的，唯一能说上几句话的就是两个市中的小朋友，期间心态也是各种不平。那段时间还好有 Spotlight Stories 啊，也算是无聊的时候的一点慰藉。GH 说好要打给我也没打，很无奈。最靠谱的还是 GR，讲义还帮我拿文件袋装好。<br>结束那天去 GH 楼下拿作业，喝了半小时西北风，也是很无奈。</p><p>那个寒假重心偏来移去的，一会 OI 一会文化课，可能效率真的不高吧。</p><p>去学校前两三天心态又炸了，不过看了看日记，调回来不少。那段时间就是真正的 <a href="https://thebesttv.github.io/2018/02/23/after_winter_holiday/">小高考，再是OI</a> 的转变了，但心里终究有点什么。<br>小高考备考的三个星期说长不长，道短不短，但终究是结束了。其实个人觉得小高考第一天心态还算可以（虽然事后发现成绩不如人意），但周围 GR、BRY 都说政治没考好。<br>最大的转变可能就在第一天的第二节晚自修吧，可以说心情直接低到底谷，具体原因的话，我只能说是我自己的问题，怪不得别人。第二天快到考场了， BRY 突然发现准考证忘拿了，于是跑回去拿，我像个傻子一样等在考场外面。</p><p>考完突然充满感情，给不少人发了祝福，之后回到OI。</p><blockquote><p>明天我至少要给我熟识的或者曾经熟识的大部分人发一条祝福吧，也算是感谢他们了。<br>再过十几天就是省选一试了，也算是倒数第二次比赛、一个再爱OI一次的机会吧。<br>停课基本上是不可能也不会了，不过晚二基本上还是会照常去的。<br>这三个星期眼睛算是废了，希望能调回来吧。<br>看到忧郁的黑客的一段博文：<br>“你知道自己的人生激情是什么吗？可能你并不知道，正如曾经的我。但是，当你发现自己深刻地爱上一样东西时，绝不放手。因为，它或许就是上帝对你的微笑。”<br>我表示同意大部分。<br>最后一个多月，再爱OI一次。</p></blockquote><p>然后是<strong>“被迫的”</strong>春游，上海科技馆还挺好玩的吧。</p><p>马上到四月份的省选一试，又一个好心的老师带我去南理工，他还是把全家都带过去的，也是去旅个游吧。碰到一个学姐，不过没说什么话。<br>不想写什么考试游记，简而言之，我考砸了，可以说是垫底。<br>现在想起来，心仍然会沉到谷底啊。<br>不过那两三天，我至少认识了 ZQY ，发现南理工鸟挺多。</p><p>随之而来的一个星期充满了这一年最大的打击。AFO、小高考2A、换位置，在一个星期里——确切地说，是两天里。这是我实在没有想到的，回想起来仍是语塞，“累累若丧家之犬”？</p><blockquote><p>今天于是又出去散心了。走到拆了的一中突然想进去看看，于是就先看了操场，再是励实楼，最后又看了几乎每个教室。还是看到不少好玩的东西的，虽然被吓得不轻…<br>走之前突然发现门口有一只猫，就和它玩了起来，之前本来想喂狗的豆腐干也正好派上了用场。也是第一次和猫玩吧，感觉它挺好玩的。<br>然后又是 routine ，跑到小学再回家。</p></blockquote><blockquote><p>说实话，本来我想借这次去寻找一下高考的动力，结果没怎么找到。<br>不过说实话，到一中看完，特别是和猫玩了一会，我就隐约感觉这趟旅程完满了。我至少有点动力了，就是周围那些好玩的啊。</p></blockquote><p>之后的事不提也罢，总之我从剧变慢慢走出，开始从 OI 到文化课的转变。<br>我开始习惯左边做着 LYY ，开始正视一团糟的成绩，开始努力甩去与过去的瓜葛，并走向新的未来。<br>期中考试算是给了我一点鼓励，班里勉强第六。<br>课本剧我竟然答应了去演 渔父 ，我们宿舍还策划了一场小小的“谋反”，我竟在凌晨花半小时查屈原的生平。</p><p>到期末考试都发生了什么，我基本上记不清了。<br>对了，有菁马跑，有 ZYF 陪我撑到最后；六月份有18届的高考，有 YWX，有 Candy? 。</p><p>这个暑假是我高中利用的最好的暑假（上一个大半都给竞赛了）。最值得写的就是我开始去楼下补语文，开始慢慢“会”写一点作文吧。</p><blockquote><p>甲壳虫的春天<br>刷题的日子，总是有些枯燥，像是小小的甲壳虫在无尽的树干上艰难地攀爬。<br>一道题，想了几天，终于完成。敲下思路，保存，关机。将机房的灯关上，门锁好。空荡荡的机房，电脑旁，是一只小甲壳虫的守望——你送的画我还好好地存着，我不会忘记那只小甲壳虫，艰难地爬到最高的树上，注视着远处的嫩绿的青草，背上几片雪花在阳光下熠熠发光。<br>三年前，你还在高一吧。那时选竞赛，他们选的不是数学就是物理，唯独你选择了信息学。我们学校向来是以前两者见长的，你也不是老师同学口中的“电脑天才”，可你说你更喜欢计算机与算法，于是你选择了它。<br>当他们聚在大教室里打打闹闹，听老师讲微积分时，你独自在教室，捧着书学习最基本的语言。当他们开始爬上属于自己的树梢时，你终于跨过第一关，真正接触算法。<br>你开始像那小甲虫一样，努力爬到最高的树上。你发觉刷题的重要，你找电脑老师找班主任找教务处，终于得到了梦寐以求的机房钥匙。那天，你高兴得带来了那幅画。<br>自此，高一高二的每一个夜晚，你都在机房中度过。<br>白天，你和他们一起安静地待在教室，做着一样的作业。上课时你也会举手，下课了你也会玩耍。晚自修前，你背上鼓鼓囊囊的书包，独自走过幽幽的长廊，来到上锁的机房。三个半小时的时光，面对电脑，调试程序与代码，屏幕的荧光照亮小甲壳虫的守望。<br>平凡的小甲虫想要爬到高高的树上，可这实在是太难了。俞敏洪最初在冬夜拎着浆糊张贴新东方的广告。甘地一次又一次绝食，为了心中“非暴力”的梦想。你不是老师同学口中的“电脑天才”，你也没有非凡的智商，你甚至要好几天才能理解一个简单的算法。可你拥有对信息学的渴望，你知道做出一道题后小小的骄傲，你见过凌晨校园黑暗的模样，还有四点半初升的朝阳……<br>苔花如米小，也学牡丹开。小小的甲壳虫没有上天赐予的翅膀，只有细细的腿与心中的渴望。<br>你也曾孤独过、迷茫过，觉得无尽的树干是渺茫的未来，纤细的小腿禁不住狂风的摧残。可你最终还是选择向上。你说你爱那些精妙绝伦的算法，你说偌大的互联网上有许多人同你一样，你说平凡人也有权利追逐自己的梦想，你说小甲虫也能看见春天的光芒……<br>回忆起刷题的日子，枯燥中散发光芒。平凡的小甲虫终于爬到最高的树上，痴痴地望着心中的远方。</p></blockquote><p>补课的时候遇到 GH、HYQ ，知道了一中现在高二的 DA ，那是挺好玩的一个人吧。</p><p>已经 <code>2019-01-01 00:48:50</code> 了，好像要快点写了。</p><p>八月份最大的事情就是那两只斑鸠了，开学前几天光顾着伺候它们了。<br>开学一周后又发生了一件不小的事，我找到 GR ，她帮我找到 CR，那两只斑鸠可算有了着落。<br>慢慢发现 CR 可能是个和 GR 一样好的人，真是佩服她们还有 BD 这么幸运是好朋友。</p><p>九月份到现在，说实话可能还不太适合回忆，就只写两三件事吧。<br>一是运动会，各种欢乐。我也可算下去了，也把感谢信给了 CR 。GH 颠球很神奇，HYQ 200米决赛拉伤了腿，BRY 接力跑挺好玩，GR 跑下了三千米，GH、LJY 三千米冲刺几乎狂奔。我们班的拔河是最厉害的吧，GH、XC、HYQ、ZYD、WY爸，很多人都很卖力。<br>还有艺术节，这是我第一次去，有 BRY 和 WZC 陪着，吃了顿还算可以的午饭，看到 CR 三次 XD。<br>最后就是圣诞节 CR 送的蛋了，老欢乐了。回家好不容易把蛋处理了一下，希望能保存着吧。</p><img src="/2019/01/01/NewYear_2019/2.jpg"><p>元旦放假当天菁园下起了雪，GH 和我在柳池附近玩了挺久。我摆了一个 New Year ，他看松树，临走还在门口顺了一个香橼……</p><p>总之这就是我的 2018 ，一个充满转变的年份。</p><p>终于渐渐远离 OI 了，也不知 zbtrs 什么时候从<a href="https://www.cnblogs.com/zbtrs/" target="_blank" rel="noopener">博客园</a>迁移到 <a href="https://zbtrs.github.io/" target="_blank" rel="noopener">github</a> 上了；也不知 scarlyw 进队后怎么样了，NOI 有拿到 PKU 一本吗？还有那么多人，Candy?、Menci、Capella，仿佛不怎么记得他们了。</p><h1 id="look-forward"><a href="#look-forward" class="headerlink" title="look forward"></a>look forward</h1><p>之后的展望，短期就是一模，长期就是高考。<br>具体不说了，已经 1:11 了，要睡觉了。</p><h1 id="周围的人"><a href="#周围的人" class="headerlink" title="周围的人"></a>周围的人</h1><p>I’m blessed with all of them, one way or another.<br>GR、ZYD、GH、WXC、DSY、HYQ、YY，等等等等。</p><p>不说了，睡吧，and wake up to a better tomorrow.</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/01/NewYear_2019/1.jpg&quot; title=&quot;New Year 2019&quot;&gt;

&lt;p&gt;So what is new year?&lt;br&gt;It’s a time for reflection: all you’ve done in the past year — all the achievements you’ve made, all the failures you’ve experienced, all the setbacks you’ve conquered; and all the sweetness you’ve enjoyed, all the bitterness you’ve tasted, something one can call “bittersweet”.&lt;br&gt;But it goes far beyond that. It’s the end of this year, but the starting point of a whole new one, one that you can hope for, one that you can have the wildest imagination about. The year 2019 is a year full of possibilities, and of course, for me, full of tests &amp;amp; scores &amp;amp; mistakes &amp;amp; corrections. And the most important, 高考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初赛一周年</title>
    <link href="https://thebesttv.github.io/2018/10/13/%E5%88%9D%E8%B5%9B%E4%B8%80%E5%91%A8%E5%B9%B4/"/>
    <id>https://thebesttv.github.io/2018/10/13/初赛一周年/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-08-04T13:35:39.545Z</updated>
    
    <content type="html"><![CDATA[<p>没有想到距离 NOIP2017 的初赛已经一年了，time does fly, right？</p><a id="more"></a><p>在这一年里当然发生了各种奇怪的事，不过也没什么，下个月还有复赛一周年呢 XD</p><p>去年立的 flag 总算是倒了，NOIP2018 我是不会去了。看来未来总是那么扑朔迷离啊，nothing’s ever for sure。不知道我们学校今年有谁会接着我的梦想呢，也不知道今年的初赛会不会闹出什么锅呢？</p><p>他们化竞的结果这周终于揭晓了，yyc 没有省队，myw、gr 没有省一，但至少还有几个可爱的人圆梦了吧。<br>故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。<br>我相信努力总是有成效的，就如同雨后定能有彩虹；我也相信好人终究有好报，a nice person will always go along。</p><p>ps. 运动会的还没写呢，恐怕要到很久之后才可能写了。<br>pps. 今天好像是路大佬的生日啊，happy coincidence，huh？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有想到距离 NOIP2017 的初赛已经一年了，time does fly, right？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>斑斑鸠鸠</title>
    <link href="https://thebesttv.github.io/2018/10/13/%E6%96%91%E6%96%91%E9%B8%A0%E9%B8%A0/"/>
    <id>https://thebesttv.github.io/2018/10/13/斑斑鸠鸠/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-08-04T13:36:07.961Z</updated>
    
    <content type="html"><![CDATA[<p>2018-08-26 10:25<br>于是两只斑鸠找到了新主人，有爱心的 CR ，哦耶~</p><a id="more"></a><p>2018-10-13 21:03<br>国庆的时候两只已经都放飞了，我就当一个 well-wisher 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-08-26 10:25&lt;br&gt;于是两只斑鸠找到了新主人，有爱心的 CR ，哦耶~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>相思树</title>
    <link href="https://thebesttv.github.io/2018/09/01/%E7%9B%B8%E6%80%9D%E6%A0%91/"/>
    <id>https://thebesttv.github.io/2018/09/01/相思树/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2019-08-04T13:36:20.693Z</updated>
    
    <content type="html"><![CDATA[<p>看了南方周末的一篇文章：<a href="http://www.infzm.com/content/137992" target="_blank" rel="noopener">守卫西南边境线：感受变与不变</a>，挺有感触的，于是就写了，照着暑假里那篇作文的结构。</p><a id="more"></a><p>感觉题目没起好，字数也多了点，不过暂时就这样吧，等会给 fd 看一下。<br>之后说不定会写一篇关于边境农民排雷的（吧……）。</p><p>#正文<br>相思花开，落黄遍地。金鸡山顶，看着伫立你，看着前方的山川天际，还有山下繁荣的土地。<br>太阳还在云层里，山间水汽氤氲，萦绕着山顶。你松树般笔直地挺立，不放过远方的任何动静，身旁的相思树与你一同站立。<br>望着你的身影，想起曾经的点点滴滴。<br>七年前，刚进入大学一个月，还没来得及谈场恋爱，你就来了——来当兵。面对他人的不解，你说你向往，那铮铮铁骨的荣誉精神。<br>当他们还沉浸在初入大学的新鲜感时，你已背上行囊，来到几千公里外的广西。当他们学有所成毕业时，你依然站在这里。他们的青春是奔放而热烈的牡丹花，你的青春却在这里被消磨殆尽，一如山顶不被知晓的相思树。<br>没有手机信号的边境，对刚来哨所的你，简直是一种煎熬。像是回到了前文明时代，曾经的朋友逐渐远离。你抱怨吃饭的时间太短，身边总有不知名的毒虫。你不喜欢三四月份的湿气，让好不容易晒得半干的被子，一个晚上又能挤出水来。你说你看到那棵树就想家，想念母亲的锅巴。<br>七年间，训练、巡逻、站岗，单调又固定，像太阳总在东方升起。<br>每月至少八次的巡逻，一次就是一整天。早晨八点，背上枪，带上锄头、砍刀，还有一支小心揣着的朱笔。二十多公里的路途，穿过茂密的原始森林，趟过奔腾的河流，还要循着前人的足迹跨过危险的雷区。战友和军犬是最忠实的伴侣，毒蛇和蚂蝗是最常见的东西。<br>终于来到界碑，你说那是最庄严的地方，你说无论多累，到那时总会挺直腰杆。走近，擦拭，描红，宣誓，最后拍下带着当天日期的相片。你说那就是你曾经向往的，那就是荣誉。<br>今天是你站岗的日子，无需跋涉几十公里，但也没有丝毫的轻松。太阳早已升离云层，悬在半高的天。山雾消去，一切变得清晰又锐利。机警的山雀不时飞来，忙了一阵又离开。<br>家寄江东远，身对江西春。空见相思树，不见相思人。戍边守关总带着单调与思念。七年，见到的永远是那几个人，手中那杆枪，袋中那支朱笔，还有那被走过一遍又一遍的老路。你不记得多少次，于站岗之时，想起母亲，想起家乡。<br>你不是那些兵中最神气的，不能在阅兵大典上面对镜头，深情地望着你守护的那方百姓。你忍受着几十公里跋涉的煎熬，还有三四月早晨湿漉漉的被子。你担心脚下那些被遗弃的地雷哪天会伤到你的战友。<br>可你仍然坚持着。你说你喜欢那某条路旁那株风铃草，你说你看过日出东方，数过流星飞向远方。你说你知道献身于一项事业的骄傲，用朱笔在界碑上描下“中国”二字的自豪，还有菜园里故乡泥土的芬芳。<br>空气渐渐炎热起来，刺眼的太阳烘烤着金鸡山的大地。七年，曾经青涩的少年，变为面前汗流浃背却纹丝不动的战士，在寂寞中守望繁荣。<br>相思树下，一代又一代的哨兵曾在此站岗，不变的是他们的守望。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了南方周末的一篇文章：&lt;a href=&quot;http://www.infzm.com/content/137992&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;守卫西南边境线：感受变与不变&lt;/a&gt;，挺有感触的，于是就写了，照着暑假里那篇作文的结构。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>（转、改）古汉语中的六个主要兼词</title>
    <link href="https://thebesttv.github.io/2018/08/17/%EF%BC%88%E8%BD%AC%E3%80%81%E6%94%B9%EF%BC%89%E5%8F%A4%E6%B1%89%E8%AF%AD%E4%B8%AD%E7%9A%84%E5%85%AD%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%85%BC%E8%AF%8D/"/>
    <id>https://thebesttv.github.io/2018/08/17/（转、改）古汉语中的六个主要兼词/</id>
    <published>2018-08-17T13:00:31.000Z</published>
    <updated>2019-08-04T13:36:31.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何谓兼词"><a href="#何谓兼词" class="headerlink" title="何谓兼词"></a>何谓兼词</h1><p>兼词，即一个音节中包含着两个音节的词，如“诸”包含“之于（wū）”或“之乎”，“叵”包含“不可”。<br>兼词同时具有那两个词的意义和用法。</p><a id="more"></a><h1 id="六个主要兼词"><a href="#六个主要兼词" class="headerlink" title="六个主要兼词"></a>六个主要兼词</h1><h2 id="盍"><a href="#盍" class="headerlink" title="盍"></a>盍</h2><h3 id="兼“何不”"><a href="#兼“何不”" class="headerlink" title="兼“何不”"></a>兼“何不”</h3><p>可直接译为“何不”，或译为“为什么不”。</p><blockquote><p>颜渊、季路侍。子曰：“<strong>盍</strong>各言尔志？”子路曰：“愿车马，衣轻裘，与朋友共，敝之而无憾。”颜渊曰：“愿无伐善，无施劳。”子路曰：“愿闻子之志。”子曰：“老者安之，朋友信之，少者怀之。”——（《论语·公冶长》）</p></blockquote><p>“盍各言尔志？”：为什么不说说你们各自的志向呢？</p><blockquote><p>济阳之贾人，渡河，亡其舟，栖于浮苴之上，号焉。有渔者以舟往救之，未至，急号曰：“我，济上之巨室，能救我，予尔百金。”渔者载而升诸陆，则予十金。渔者曰：“向许百金而今予十金，无乃不可乎？”贾人曰：“若，渔者也，一日之获几何？骤得十金，犹为不足乎？”渔者黯然而退。他日，贾人浮吕梁而下，舟薄于石，又覆。而渔者在焉。人或曰：“<strong>盍</strong>救诸？”渔者曰：“是许金而不酬者也。”立而观之，遂没。</p></blockquote><p>“盍救诸”：为什么不救他呢？</p><blockquote><p>王欲行之，则盍反其本矣。<br>以一服八，何以异于邹敌楚哉？盍亦反其本矣。（为什么不返回到根本上来呢）<br>——《孟子·齐桓晋文之事》</p></blockquote><h2 id="诸"><a href="#诸" class="headerlink" title="诸"></a>诸</h2><h3 id="兼“之于（wu）”"><a href="#兼“之于（wu）”" class="headerlink" title="兼“之于（wū）”"></a>兼“之于（wū）”</h3><p>“诸”若处于句中，且不是代词，就是兼词，兼“之于”（“之”是代词，“于”是介词），其中“于”古音为 <code>wū</code>。</p><blockquote><p>渔者载而升<strong>诸</strong>陆，则予十金。</p></blockquote><blockquote><p>（阳处父）追<strong>诸</strong>河，则在舟中矣。——《殽之战》</p></blockquote><p>翻译：（阳处父）追赶他们到了黄河边上，他们原来已经坐在船上了。</p><p>懂得了这一点，对于现代汉语也是有帮助的。<br>如病句“诉诸于法律”、“付诸于行动”，句中的“于”都必须去掉，因为“诸”是兼词，里面已经包含者一个“于”字。</p><h3 id="兼“之乎”"><a href="#兼“之乎”" class="headerlink" title="兼“之乎”"></a>兼“之乎”</h3><p>“诸”若处于句末，兼“之乎”（“之”是代词，“乎”是语气助词）。</p><blockquote><p>人或曰：“盍救<strong>诸</strong>？”</p></blockquote><p>翻译：为什么不救他呢？</p><blockquote><p>王尝语庄子以好乐，有诸？——《孟子·庄暴见孟子》</p></blockquote><p>“有诸？”：有这件事吗？</p><blockquote></blockquote><p>（孟　子）曰：“保民而王，莫之能御也。”<br>（齐宣王）曰：“若寡人者，可以保民乎哉？”<br>（孟　子）曰：“可。”<br>（齐宣王）曰：“何由知吾可也？”<br>（孟　子）曰：“臣闻之胡齕曰，王坐于堂上，有牵牛而过堂下者，王见之，曰：‘牛何之？’对曰：‘将以衅钟。’王曰：‘舍之！吾不忍其觳觫，若无罪而就死地。’对曰：‘然则废衅钟与？’曰：‘何可废也？以羊易之！’不识有<strong>诸</strong>？”（不知是否有这件事？）<br>（齐宣王）曰：“有之。”<br>（孟　子）曰：“是心足以王矣。百姓皆以王为爱也，臣固知王之不忍也。”<br>——《孟子·齐桓晋文之事》</p><h2 id="焉"><a href="#焉" class="headerlink" title="焉"></a>焉</h2><h3 id="兼“于之”"><a href="#兼“于之”" class="headerlink" title="兼“于之”"></a>兼“于之”</h3><p>用于句末，是介词“于”和代词“之”，两个词的兼词。<br>翻译的时候，需要具体问题具体对待。</p><blockquote><p>积土成山，风雨兴<strong>焉</strong>；积水成渊，蛟龙生<strong>焉</strong>。（在那里）</p></blockquote><blockquote><p>青麻头伏<strong>焉</strong>。（在那里）——《促织》</p></blockquote><blockquote><p>彭蠡之扣有石钟山<strong>焉</strong>。（在那里）——《石钟山记》</p></blockquote><blockquote><p>余收尔骨<strong>焉</strong>。（到那里）——《殽之战》</p></blockquote><blockquote><p>或师焉，或否<strong>焉</strong>。（向老师）——《师说》</p></blockquote><h2 id="耳"><a href="#耳" class="headerlink" title="耳"></a>耳</h2><h3 id="兼“而已”"><a href="#兼“而已”" class="headerlink" title="兼“而已”"></a>兼“而已”</h3><p>用在句末，表示限止性语气。可以直接翻译为“而已”，也可以译为“罢了”。</p><blockquote><p>王变乎色曰：“寡人非能好先王之乐也，直好世俗之乐<strong>耳</strong>！”——《孟子·庄暴见孟子》</p></blockquote><blockquote><p>从此道至吾军，不过二十里<strong>耳</strong>。——《鸿们宴》</p></blockquote><h2 id="叵"><a href="#叵" class="headerlink" title="叵"></a>叵</h2><h3 id="兼“不可”"><a href="#兼“不可”" class="headerlink" title="兼“不可”"></a>兼“不可”</h3><p>《说文新附·可部》中说：“叵，不可也。”<br>现代汉语已经不用“叵”，它只保留在某些成语中，如“居心叵测”中的“叵”就是“不可”的意思。它用于动词前，表示动作行为不能实现或无法实现，可译为“不可”、“不可能”。</p><blockquote><p>布因指（刘）备曰：“是儿最<strong>叵</strong>信者。”——《三国志·魏书·吕布传》</p></blockquote><p>翻译：这小子是最不可信任的。</p><blockquote><p>（尹愔）尝受学于国子博士王道珪，称之曰：“吾门人多矣，尹子<strong>叵</strong>测也。”——《新唐书·尹愔传》</p></blockquote><p>翻译：我的弟子很多，尹愔是最不可测度的</p><h2 id="旃-XD"><a href="#旃-XD" class="headerlink" title="旃 XD"></a>旃 XD</h2><h3 id="兼“之焉”"><a href="#兼“之焉”" class="headerlink" title="兼“之焉”"></a>兼“之焉”</h3><p>作为一个兼词，它除了具有代词性，指代人或事物外，还兼有劝勉或揣度语气，可以理解为它就是“之焉”（或者理解为“之也”亦可）两个词的兼词。</p><blockquote><p>舍<strong>旃</strong>！舍<strong>旃</strong>！苟亦无然。——《诗经·唐风·采苓》</p></blockquote><p>翻译：丢掉它吧！丢掉它吧！确实不要认为是那样。</p><blockquote><p>夫睹之者掩口卢胡而笑，斯文之族，无乃类<strong>旃</strong>。——《后汉书·应劭传》</p></blockquote><p>翻译：那些看到了这种情况的人掩起口来胡噜而笑，斯斯文文的俗人，恐怕与此相类似吧。<br>“无乃…乎/欤？”译为“恐怕…吧”。该句中没有“乎/欤”，“吧”是由“旃”中隐含着的“焉”翻译出来的。</p><blockquote><p>方当盛汉之隆，愿勉<strong>旃</strong>，毋多谈。——《汉书·杨恽传》</p></blockquote><p>翻译：正当汉朝非常昌盛之时，（你）为自己的功名努力吧，不须跟我多谈论。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="http://blog.sina.com.cn/s/blog_464934350102wgw9.html" target="_blank" rel="noopener">古汉语中的六个主要兼词 孙长江</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;何谓兼词&quot;&gt;&lt;a href=&quot;#何谓兼词&quot; class=&quot;headerlink&quot; title=&quot;何谓兼词&quot;&gt;&lt;/a&gt;何谓兼词&lt;/h1&gt;&lt;p&gt;兼词，即一个音节中包含着两个音节的词，如“诸”包含“之于（wū）”或“之乎”，“叵”包含“不可”。&lt;br&gt;兼词同时具有那两个词的意义和用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文言文" scheme="https://thebesttv.github.io/tags/%E6%96%87%E8%A8%80%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>小高考，再是OI</title>
    <link href="https://thebesttv.github.io/2018/02/23/after_winter_holiday/"/>
    <id>https://thebesttv.github.io/2018/02/23/after_winter_holiday/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2019-08-04T14:24:28.261Z</updated>
    
    <content type="html"><![CDATA[<p>寒假算是结束了，写一写从去年联赛到现在的感慨。</p><a id="more"></a><p>本来21号就已经开始写了，不过又重新想了一想。</p><p>明天就要回学校了，也算是正式开始冲刺小高考了吧。至于OI，得暂时放一下了。<br>等到小高考结束，马上是省选。省选结束，可能就要AFO了吧。<br>今年的NOIP应该是不会去了。毕竟，也要高考了，到高三可能真的不会有时间、有机会了吧。</p><p>也有点不知道该说什么好。<br>从去年的联赛到现在，心态起起浮浮崩了好多次，也算终于快调回来了吧。</p><p>不过，我也开始学会妥协了。<br>真的还是要高考，还是要小高考的啊。<br>再怎么都不能逃避了。</p><p>贴一贴前几天的日记吧。</p><blockquote><p>So, maybe that’s what I want to say: be grateful for what you have, and work hard for everything you’ll have to do. (yes, EVERYTHING you’ll have to do.)</p><p>没有妥协，怎么是成长呢？<br>没有奋斗，怎么是人生呢？</p><p>对，奋斗，为了每一件你该做好的事，无论是小高考，还是语文、物化，还是将来任何一件事。</p><p>可能之后还会有片刻的颓，但我相信，我会一直奋斗。</p><p>再贴一贴原来的日记吧：</p><blockquote><p>Hope for the best, and prepare for the worst</p><p>的确，结果好不好、能不能拿奖不是最重要的，重要的是过程，是将来想到曾经的自己能这样每天为了自己的爱好而拼搏</p><p>最后讲讲心路历程吧。一开始我是很有热情的，不过好像就是初赛前一段时间，不清楚为什么，我没那么大热情了。到了前一个月，心情基本上都是不好的，可能就是缺爱了吧XD，也没什么朋友，随意吧。记得之前哪篇日记上我说过不关心是不是alone，不过现在发现孤独还是没那么好玩的。也是很无奈。<br>基本上就是那么多了吧，也写了有半个多小时了，车上一堆都是无锡的大佬。</p><p>可能总是要试试吧，拼一拼，结果再怎么样也不会后悔了。</p></blockquote></blockquote><p>最后，希望这都不会是空话吧。</p><p>暂别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假算是结束了，写一写从去年联赛到现在的感慨。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[CF 934A] A Compatible Pair</title>
    <link href="https://thebesttv.github.io/2018/02/18/CF_934A/"/>
    <id>https://thebesttv.github.io/2018/02/18/CF_934A/</id>
    <published>2018-02-17T16:00:00.000Z</published>
    <updated>2019-08-04T14:35:48.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>甲（小Tommy）乙（大Banban）两人分别有 $n,m$ 个灯笼，甲每个灯笼的分值为 $a_i$ ，乙的为 $b_i$ 。</p><p>甲先进行选择，他会隐藏一个灯笼 $a_i$ ；<br>然后乙进行选择，他在剩下的灯笼中选择 $a_i$ 和 $b_j$ ，得到 $a_i b_j$ 分。<br>甲想要让乙得分最小，而乙想要自己得分最大。<br>现假设两人的决策都为最优，求出乙的得分。</p><a id="more"></a><h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>（恐怕自己题目大意是说不清了…… hh）</p><p>Little Tommy has $n$ lanterns and Big Banban has $m$ lanterns. Tommy’s lanterns have brightness a1, a2, …, an, and Banban’s have brightness b1, b2, …, bm respectively.</p><p>Tommy intends to hide one of his lanterns, then Banban picks one of Tommy’s non-hidden lanterns and one of his own lanterns to form a pair. The pair’s brightness will be the product of the brightness of two lanterns.</p><p>Tommy wants to make the product as small as possible, while Banban tries to make it as large as possible.</p><p>You are asked to find the brightness of the chosen pair if both of them choose optimally.</p><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>So，直接枚举 Tommy 选哪个灯笼然后看 Banban 的最优决策是否最小即可。</p><p>然而比赛的时候第一次被 Hack 掉，第二次错了……</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m; LL a[MAX],b[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">  FORR(i,<span class="number">1</span>,n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  FORR(i,<span class="number">1</span>,m) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">  LL ansMin=<span class="number">1L</span>L&lt;&lt;<span class="number">62</span>;</span><br><span class="line">  FORR(k,<span class="number">1</span>,n)&#123;  <span class="comment">//选a[k]</span></span><br><span class="line">    LL tMax=-(<span class="number">1L</span>L&lt;&lt;<span class="number">62</span>);</span><br><span class="line">    FORR(i,<span class="number">1</span>,n) <span class="keyword">if</span>(i!=k) FORR(j,<span class="number">1</span>,m)  <span class="comment">//在剩下的中选出最大的</span></span><br><span class="line">      tMax=max(tMax,a[i]*b[j]);</span><br><span class="line">    ansMin=min(ansMin,tMax);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ansMin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;甲（小Tommy）乙（大Banban）两人分别有 $n,m$ 个灯笼，甲每个灯笼的分值为 $a_i$ ，乙的为 $b_i$ 。&lt;/p&gt;
&lt;p&gt;甲先进行选择，他会隐藏一个灯笼 $a_i$ ；&lt;br&gt;然后乙进行选择，他在剩下的灯笼中选择 $a_i$ 和 $b_j$ ，得到 $a_i b_j$ 分。&lt;br&gt;甲想要让乙得分最小，而乙想要自己得分最大。&lt;br&gt;现假设两人的决策都为最优，求出乙的得分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeForces" scheme="https://thebesttv.github.io/tags/CodeForces/"/>
    
      <category term="模拟" scheme="https://thebesttv.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>[CQOI 2015] 选数</title>
    <link href="https://thebesttv.github.io/2018/02/15/CQOI_2015_number/"/>
    <id>https://thebesttv.github.io/2018/02/15/CQOI_2015_number/</id>
    <published>2018-02-15T04:26:00.000Z</published>
    <updated>2018-02-15T13:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 $n,k,l,r$ ，在 $[l,r]$ 中任选出 $n$ 个数组成集合 $N$ ，并且满足 $gcd\{N\}=k$ 。求出方案数。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>表示一开始各种尝试，完全没有思路啊……<br>不过最后还是自己做出来了 XD</p><p>令 $f(n,k,l,r)$ 表示：在 $[l,r]$ 中选出 $n$ 个数组成集合 $N$ ，并且满足 $gcd\{N\}=k$ 的种数，则 $ans=f(n,k,l,r)$ 。</p><h2 id="问题的简化"><a href="#问题的简化" class="headerlink" title="问题的简化"></a>问题的简化</h2><p>先举一个例子：<br>　当 $ k=4, l=14, r=33 $ 时，有集合 $\{14,15,\ldots,33\}$ ，而真正可选的集合只有 $\{ 16,20,24,26,32\}$ ，都为 $k$ 的倍数。也可以说 $[14,33]$ 被简化到了 $[ \lceil l/k \rceil, \lfloor r/k \rfloor ] = [16,32]$ 。<br>　若 $n=2$ ，只能选 $ \{16,20\}, \{16,28\}, \cdots $ ，而不能选 $\{16,24\}$ 之类的，因为 $16,24$ 中 $k$ 的系数分别为 $4,6$ ，而 $(4,6)=2$ ，那么 $(16,24)=(4,6) \times 4=8$。</p><p>从这里我们可以看出：</p><ol><li>因为要求 $gcd\{N\}=k$ ，则任意被选择的数 $x_i$ 都为 $k$ 的倍数。而且，将所有 $x_i$ 表示成 $x’_i \cdot k$ 时，必有 $gcd\{x’_i\}=1$ 。若不满足，则 $gcd\{N\} = gcd\{x_i\} \cdot k \neq k$ 。</li><li>我们就可以将整个可选集合简化为（除以 $k$ 后）系数的形式，并将原问题简化为：给定 $n,k,l,r$ ，在 $[\lceil l/k \rceil, \lfloor r/k \rfloor]$ 中任选出 $n$ 个数 $gcd\{N\}=1$ 。<br>需要注意的是，原问题中 $[l,r]$ 内只能选取 $k|x_i$ 的，而现在 $[\lceil l/k \rceil, \lfloor r/k \rfloor]$ 内的每个数都可选择。</li></ol><p>对应例子，即：将 $\{ 16,20,24,26,32\}$ 改为 $\{4,5,6,7,8\}$ ，从中选出 $n$ 个数使得 $gcd\{N\}=1$ 。</p><p>这样，就有<br>$$ ans = f(n,k,l,r) = f\left(n,1, \left\lceil \frac{l}{k} \right\rceil, \left\lfloor \frac{r}{k} \right\rfloor \right) $$</p><p>当然，这样才只是个开始，还要想办法求出 $f$ 。</p><h2 id="对-f-求解"><a href="#对-f-求解" class="headerlink" title="对 $f$ 求解"></a>对 $f$ 求解</h2><p>看到 $gcd\{N\}=k$ ，<del>自然</del>想到莫比乌斯反演。<br>令 $F(n,k,l,r)$ 表示：在 $[l,r]$ 中选出 $k$ 个数组成集合 $N$ ，并且满足 $k|gcd\{N\}$ 的种数。<br>显然，$F$ 就是在所有 $k|x_i$ 的数中选取。令 $g(k,l,r)$ 表示表示区间 $[l,r]$ 中 $k$ 的倍数的个数，就有<br>\begin{split}<br>  F(n,k,l,r) &amp;= g(k,l,r)^n = \left( \left\lfloor\frac{r}{k}\right\rfloor-\left\lfloor\frac{l-1}{k}\right\rfloor \right)^{\large n} \\<br>  F(k) &amp;= ( f * 1 ) (k) \\<br>  \implies f(n,k,l,r) &amp;= \sum_{k|d} \left( \left\lfloor\frac{r}{d}\right\rfloor-\left\lfloor\frac{l-1}{d}\right\rfloor \right)^n \mu\left(\frac{d}{k}\right) \\<br>\end{split}</p><p>而 $ans$ 中只需要 $k=1$ ，就可以方便地分块：<br>$$ f(n,1,l,r) = \sum_{d=1}^{r} \left( \left\lfloor\frac{r}{d}\right\rfloor-\left\lfloor\frac{l-1}{d}\right\rfloor \right)^{\large n} \mu(d) $$</p><p>不过 $r$ 可能高达 $10^9$ ，于是套上杜教筛，和分块完美结合 XD</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_=MAX+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,l,r;</span><br><span class="line"><span class="keyword">int</span> mu[MAX_],prime[MAX],tail;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX_];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  FORR(i,<span class="number">2</span>,MAX)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      prime[tail++]=i;</span><br><span class="line">      mu[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(j,<span class="number">0</span>,tail)&#123;</span><br><span class="line">      <span class="keyword">int</span> t=i*prime[j];</span><br><span class="line">      <span class="keyword">if</span>(t&gt;MAX) <span class="keyword">break</span>;</span><br><span class="line">      vis[t]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">        mu[t]=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        mu[t]=-mu[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FORR(i,<span class="number">2</span>,MAX) mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=MAX) <span class="keyword">return</span> mu[n];</span><br><span class="line">  <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">  LL a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">    j=n/(n/i);</span><br><span class="line">    a = ( a - S(n/i)*(j-i+<span class="number">1</span>)%MOD + MOD )%MOD;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mp[n]=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL n, LL a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> n%MOD;</span><br><span class="line">  LL ans=pow_mod(n,a&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  ans=ans*ans%MOD;</span><br><span class="line">  <span class="keyword">if</span>(a&amp;<span class="number">1</span>) ans=ans*n%MOD;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL n, LL l, LL r)</span></span>&#123; <span class="comment">// f(n,1,l,r)</span></span><br><span class="line">  LL ans=<span class="number">0</span>; l-=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=r;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">    j=r/(r/i);</span><br><span class="line">    <span class="keyword">if</span>(l/i) j=min(j,l/(l/i));</span><br><span class="line">    ans = ( ans + (S(j)-S(i<span class="number">-1</span>)+MOD)%MOD * pow_mod(r/i-l/i,n) %MOD ) %MOD;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  init(); <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;l,&amp;r);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f(n,<span class="built_in">ceil</span>(<span class="number">1.0</span>*l/k),r/k));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定 $n,k,l,r$ ，在 $[l,r]$ 中任选出 $n$ 个数组成集合 $N$ ，并且满足 $gcd\{N\}=k$ 。求出方案数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="莫比乌斯反演" scheme="https://thebesttv.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="杜教筛" scheme="https://thebesttv.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
      <category term="省选" scheme="https://thebesttv.github.io/tags/%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI 2008] 奖励关</title>
    <link href="https://thebesttv.github.io/2018/02/13/SCOI_2008_bonus/"/>
    <id>https://thebesttv.github.io/2018/02/13/SCOI_2008_bonus/</id>
    <published>2018-02-13T09:51:00.000Z</published>
    <updated>2018-02-15T13:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有 $n$ 种物品，每种物品都有一个可正可负可为零的价值，且选取第 $i$ 种物品要满足它的先决条件：在选取之前已拥有集合 $Si$ 中的所有物品。<br>有 $k$ 轮，每轮随机给出一个物品，你可以决定是否拿取。询问采取最优策略时能够得到的期望价值。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>这是一道类似于 [UVA 10900] 的题，不过缺少了连续概率使得它非常友善 XD</p><p>考虑若当前拥有的物品集合为 $S$ ，在某轮中，给出了第 $i$ 种物品：</p><ul><li>首先判断当前是否满足它的先决条件，若不满足则直接决策不拿。</li><li>若它的价值非负，则决策拿了一定不会更坏。</li><li>若它的价值为负，若在之前已经拿取过同种物品，则决策不拿一定不会更坏。</li><li>若之前未拿取过同种物品，则要判断，拿和不拿的收益哪个更大就决策哪个。</li></ul><p>可以看出这又是一个逆序递推的过程。<br>令 $f[i,S]$ 表示当前在第 $i$ 轮已经决策好，在决策前拥有的物品集合为 $S$ 时，在之后 $n-i$ 轮能获得的的期望价值，则需要枚举每一种可能得到的物品，对于第 $j$ 种物品，依旧如上方一样：</p><ul><li>若不能选取该物品，则 $f[i,S] += f[i+1,S]$</li><li>否则，当它的价值非负时，选取更好，即 $f[i,S] += a[i] + f[i+1, S + \{j\} ]$</li><li>否则，若之前已拿过它，则不选，$f[i,S] += f[i+1,S]$</li><li>否则，判断拿取（得到 $a[i] + f[i+1, S + \{j\} ]$的价值）和不拿取（得到 $f[i+1,S]$的价值）哪个更好决策哪个。</li></ul><p>好吧还是用代码实现比较清晰……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FORR(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">  <span class="keyword">if</span>((S &amp; req[i])==req[i])&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>) ans += f(cur+<span class="number">1</span>,S|(<span class="number">1</span>&lt;&lt;i))+a[i];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>((S&amp;(<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>)&#123; <span class="comment">//分数为负且未吃过</span></span><br><span class="line">        ans += max( f(cur+<span class="number">1</span>,S|(<span class="number">1</span>&lt;&lt;i))+a[i], f(cur+<span class="number">1</span>,S));</span><br><span class="line">      &#125;<span class="keyword">else</span> ans+=f(cur+<span class="number">1</span>,S);  <span class="comment">//&lt;b&gt; &lt;/b&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> ans+=f(cur+<span class="number">1</span>,S);      <span class="comment">//&lt;b&gt; &lt;/b&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用记忆化搜索，答案即为 $f[0,0]$ 。要注意的就是每次决策都要考虑完整，不能“不拿就不决策”。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK=<span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[MAXN],req[MAXN];</span><br><span class="line"><span class="keyword">double</span> check_f[MAXK][<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXK][<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> S)</span></span>&#123; <span class="comment">//当前在第 cur 次投掷已经决策完，决策前吃过的物品集合为 S</span></span><br><span class="line">  <span class="keyword">if</span>(cur==k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(vis[cur][S]) <span class="keyword">return</span> check_f[cur][S];</span><br><span class="line">  <span class="keyword">double</span> &amp;ans=check_f[cur][S]; vis[cur][S]=<span class="number">1</span>;</span><br><span class="line">  FORR(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>((S &amp; req[i])==req[i])&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>) ans += f(cur+<span class="number">1</span>,S|(<span class="number">1</span>&lt;&lt;i))+a[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((S&amp;(<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>)&#123; <span class="comment">//分数为负且未吃过</span></span><br><span class="line">          ans += max( f(cur+<span class="number">1</span>,S|(<span class="number">1</span>&lt;&lt;i))+a[i], f(cur+<span class="number">1</span>,S));</span><br><span class="line">        &#125;<span class="keyword">else</span> ans+=f(cur+<span class="number">1</span>,S);  <span class="comment">//&lt;b&gt; &lt;/b&gt;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> ans+=f(cur+<span class="number">1</span>,S);      <span class="comment">//&lt;b&gt; &lt;/b&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ans/=n;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;n);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  FORR(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">      req[i]|=<span class="number">1</span>&lt;&lt;t;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,f(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有 $n$ 种物品，每种物品都有一个可正可负可为零的价值，且选取第 $i$ 种物品要满足它的先决条件：在选取之前已拥有集合 $Si$ 中的所有物品。&lt;br&gt;有 $k$ 轮，每轮随机给出一个物品，你可以决定是否拿取。询问采取最优策略时能够得到的期望价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>[JSOI 冬令营] D6T1 白日梦</title>
    <link href="https://thebesttv.github.io/2018/02/13/JSOI_WC_daydream/"/>
    <id>https://thebesttv.github.io/2018/02/13/JSOI_WC_daydream/</id>
    <published>2018-02-13T09:17:00.000Z</published>
    <updated>2018-02-13T10:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>你被扔到一个岛上住 $n+1$ 天（编号从$0$到$n$），每天要么是晴天，要么刮台风。第 $0$ 天一定是晴天。对于第 $i$ 天，若是晴天，则有 $p$ 的概率会变天，使得接下来 $m$ 天都刮台风，但第 $i+m+1$ 天一定转晴。<br>每天，若是晴天，则一定能抓到 $a$ 只猎物；若刮台风，则有 $1-d$ 的可能抓到 $b$ 只猎物，有 $d$ 的可能抓到 $c$ 只猎物。求出第 $1$ 天到第 $n$ 天猎物总量的期望。<br>给出的所有小数都是在模 $998244353$ 的意义下的，答案也需取模。</p><a id="more"></a><p>若小数 $a$ 写成 $\frac{x}{y}$ 的形式，则给出的数 $ a’ = x \times y^{-1} $ ，其中 $y^{-1}$ 表示 $y$ 在模意义下的逆元。</p><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>一开始到剩余系就方了，不过其实剩余系在这里并没有太大影响。<br>对于小数 $ a = \frac{x}{y} $ ，有 $ 1 - a = \frac{y-x}{y} = ( y - x ) \times y^{-1} = 1 - a + MOD $ 。于是就可以欢乐地切题了 XD</p><p>首先，和的期望等于期望的和，于是 $ ans = \sum_{i=1}^{n} E(i) $ 。<br>令 $P[i][0/1]$ 表示在第 i 天，岛上天气为晴/刮台风的可能，考虑用 $P[i][0]$ 更新其后继状态：<br>  $$ P[i][0] \to P[(i+1) : (i+m)][1] += P[i][0] \times p, P[i+m+1][0] += P[i][0] \times p $$<br>  $$ P[i][0] \to P[i+1][0] += P[i][0] \times (1-p) $$<br>答案为<br>  $$ \sum_{i=1}^{n} P[i] \cdot a + (1-P[i]) ( (1-d) \cdot b + d \cdot c ) ,, mod ,, 998244353 $$</p><p>然而这样 $O(mn)$ 会直接T……考试的时候就是这样，50多个人里十几个 AC ，就我一个 $50$ ……</p><p>考虑对于任意 $i$ ，始终有 $P[i][1] = 1-P[i][0]$ ，那么就可以去掉 $P[i][1]$ 。<br>令 $P[i]$ 表示岛上第 $i$ 天为晴天的可能，则<br>  $$ P[i] \to P[i+1+m] += P[i] \times p $$<br>  $$ P[i] \to P[i+1] += P[i] \times (1-p) $$<br>这样就可以不T了。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000020</span>;</span><br><span class="line">LL n,m,p,d,a,b,c;</span><br><span class="line">LL f[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;p,&amp;d);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">  </span><br><span class="line">  f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">    f[i+<span class="number">1</span>] = ( f[i+<span class="number">1</span>] + (<span class="number">1</span>+MOD-p)*f[i]%MOD )%MOD;</span><br><span class="line">    <span class="keyword">if</span>(i+m+<span class="number">1</span>&lt;=n) f[i+m+<span class="number">1</span>] = ( f[i+m+<span class="number">1</span>] + p*f[i]%MOD )%MOD;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LL ans=<span class="number">0</span>;</span><br><span class="line">  FORR(i,<span class="number">1</span>,n) ans = ( ans + f[i]*a%MOD + ( (<span class="number">1</span>+MOD-f[i]) *  ( (<span class="number">1</span>+MOD-d)*b%MOD + d*c%MOD )%MOD )%MOD )%MOD;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;你被扔到一个岛上住 $n+1$ 天（编号从$0$到$n$），每天要么是晴天，要么刮台风。第 $0$ 天一定是晴天。对于第 $i$ 天，若是晴天，则有 $p$ 的概率会变天，使得接下来 $m$ 天都刮台风，但第 $i+m+1$ 天一定转晴。&lt;br&gt;每天，若是晴天，则一定能抓到 $a$ 只猎物；若刮台风，则有 $1-d$ 的可能抓到 $b$ 只猎物，有 $d$ 的可能抓到 $c$ 只猎物。求出第 $1$ 天到第 $n$ 天猎物总量的期望。&lt;br&gt;给出的所有小数都是在模 $998244353$ 的意义下的，答案也需取模。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>[NOI 2006] 神奇的口袋</title>
    <link href="https://thebesttv.github.io/2018/02/13/NOI_2006_bag/"/>
    <id>https://thebesttv.github.io/2018/02/13/NOI_2006_bag/</id>
    <published>2018-02-13T08:46:00.000Z</published>
    <updated>2019-08-04T13:50:35.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个袋中的 $t$ 种颜色的球，颜色为 $i$ 的球有 $a_i$ 个。每次从袋中随机摸出一个球，记录其颜色，在将它与另外 $d$ 个颜色相同的球一同放入袋中。这样以来，会产生一个颜色序列。<br>再给出 $n$ 个条件 $(x_i,y_i)$ 表示第 $x_i$ 次摸出颜色为 $y_i$ 的球。求出颜色序列满足所有条件的可能，并将结果以最简分数形式输出。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>最近好像题目越来越长了……</p><p>首先，有一个所谓的「Pólya 瓦罐模型」：<br>在一个瓦罐中有 $n$ 个球，其中有且仅有 $n_1$ 个黑球，$n_2$ 个白球。每次从中摸出一个球，在将其与另外 $r$ 个颜色相同的球重新放入罐中，可以证明：任意一次摸出黑球的可能都是 $\frac{n_1}{n}$ ，摸出白球的可能都是 $\frac{n_2}{n}$。<br>可以通过数学归纳法证明。</p><p>那么，仿佛可以自然地联想到：给定条件的 $x$ 其实是没有意义的，唯一有意义的只是 $y$ 的相对顺序。那么就可以令 $x_i=i$ ，直接求解。</p><p>当然会需要使用高精度，可以在计算时将分子和分母分别以 $\prod p_i^{k_i}$ 的形式存储，最后化简后再用高精度乘法输出。<br><del>（表示直接而复制粘贴之前的模板 XD）</del></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT=<span class="number">1020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXP=<span class="number">20020</span>;</span><br><span class="line"><span class="keyword">int</span> n,t,d,a[MAXT];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXP+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> prime[MAXP],tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BASE=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WIDTH=<span class="number">8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BI</span>&#123;</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">  BI() &#123;len=<span class="number">0</span>;&#125;</span><br><span class="line">  BI(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;BASE) v.push_back(n%BASE), n/=BASE;</span><br><span class="line">    <span class="keyword">if</span>(n) v.push_back(n);</span><br><span class="line">    len=v.size();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,v[len<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%08d"</span>,v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(BI &amp; a, BI &amp; b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.len!=b.len) <span class="keyword">return</span> a.len-b.len;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(a.v[i]!=b.v[i])</span><br><span class="line">      <span class="keyword">return</span> a.v[i]-b.v[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BI <span class="title">add</span><span class="params">(BI a, BI b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(compare(a,b)&lt;<span class="number">0</span>) swap(a,b);</span><br><span class="line">  <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">    a.v[i]+=carry;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;b.len) a.v[i]+=b.v[i];</span><br><span class="line">    carry=a.v[i]/BASE;</span><br><span class="line">    a.v[i]%=BASE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry) a.v.push_back(carry);</span><br><span class="line">  a.len=a.v.size();</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BI <span class="title">mul</span><span class="params">(BI a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">  BI c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">    carry+=(<span class="keyword">long</span> <span class="keyword">long</span>)a.v[i]*b;</span><br><span class="line">    c.v.push_back(carry%BASE);</span><br><span class="line">    carry/=BASE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry) c.v.push_back(carry);</span><br><span class="line">  c.len=c.v.size();</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BI <span class="title">mul</span><span class="params">(BI a, BI b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(compare(a,b)&lt;<span class="number">0</span>) swap(a,b);</span><br><span class="line">  BI c,temp; c=mul(a,b.v[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">    temp=mul(a,b.v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) temp.v.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=temp.len<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) temp.v[j+i]=temp.v[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) temp.v[j]=<span class="number">0</span>;</span><br><span class="line">    temp.len+=i;</span><br><span class="line">    c=add(c,temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BI <span class="title">pow</span><span class="params">(<span class="keyword">const</span> BI &amp;n, <span class="keyword">int</span> a)</span></span>&#123;  <span class="comment">//n^a</span></span><br><span class="line">  <span class="keyword">if</span>(!a) <span class="keyword">return</span> BI(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  BI ans = <span class="built_in">pow</span>(n,a&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  ans = mul(ans,ans);</span><br><span class="line">  <span class="keyword">if</span>(a&amp;<span class="number">1</span>) ans = mul(ans,n);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FRAC</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> ex1[MAXP],ex2[MAXP];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;  <span class="comment">//添加 a/b</span></span><br><span class="line">    <span class="keyword">if</span>(a!=<span class="number">1</span>) add1(a);</span><br><span class="line">    <span class="keyword">if</span>(b!=<span class="number">1</span>) add2(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sq=<span class="built_in">sqrt</span>(n+<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail &amp;&amp; n!=<span class="number">1</span> &amp;&amp; prime[i]&lt;=sq;i++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>) n/=prime[i], ex1[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> t=lower_bound(prime,prime+tail,n)-prime;</span><br><span class="line">      ex1[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sq=<span class="built_in">sqrt</span>(n+<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail &amp;&amp; n!=<span class="number">1</span> &amp;&amp; prime[i]&lt;=sq;i++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>) n/=prime[i], ex2[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> t=lower_bound(prime,prime+tail,n)-prime;</span><br><span class="line">      ex2[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sim</span><span class="params">()</span></span>&#123; <span class="comment">//约分</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    FOR(i,<span class="number">0</span>,tail)&#123;</span><br><span class="line">      t=min(ex1[i],ex2[i]);</span><br><span class="line">      ex1[i]-=t, ex2[i]-=t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BI a(1),b(1);</span><br><span class="line">    FOR(i,<span class="number">0</span>,tail)&#123;</span><br><span class="line">      <span class="keyword">if</span>(ex1[i]) a = mul(a, <span class="built_in">pow</span>(BI(prime[i]),ex1[i]));</span><br><span class="line">      <span class="keyword">if</span>(ex2[i]) b = mul(b, <span class="built_in">pow</span>(BI(prime[i]),ex2[i]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    FOR(i,<span class="number">0</span>,tail) <span class="keyword">if</span>(ex1[i]) <span class="built_in">printf</span>(<span class="string">" %d^%d *"</span>,prime[i],ex1[i]); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    FOR(i,<span class="number">0</span>,tail) <span class="keyword">if</span>(ex2[i]) <span class="built_in">printf</span>(<span class="string">" %d^%d *"</span>,prime[i],ex2[i]); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    a.print(); <span class="built_in">printf</span>(<span class="string">"/"</span>); b.print(); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  FORR(i,<span class="number">2</span>,MAXP)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      prime[tail++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(j,<span class="number">0</span>,tail)&#123;</span><br><span class="line">      <span class="keyword">int</span> t=i*prime[j];</span><br><span class="line">      <span class="keyword">if</span>(t&gt;MAXP) <span class="keyword">break</span>;</span><br><span class="line">      vis[t]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;n,&amp;d);</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>,x,y;</span><br><span class="line">  FORR(i,<span class="number">1</span>,t) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]), sum+=a[i];</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    f.add(a[y],sum);</span><br><span class="line">    a[y]+=d, sum+=d;</span><br><span class="line">  &#125;</span><br><span class="line">  f.sim(); f.print();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个袋中的 $t$ 种颜色的球，颜色为 $i$ 的球有 $a_i$ 个。每次从袋中随机摸出一个球，记录其颜色，在将它与另外 $d$ 个颜色相同的球一同放入袋中。这样以来，会产生一个颜色序列。&lt;br&gt;再给出 $n$ 个条件 $(x_i,y_i)$ 表示第 $x_i$ 次摸出颜色为 $y_i$ 的球。求出颜色序列满足所有条件的可能，并将结果以最简分数形式输出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="Pólya 瓦罐模型" scheme="https://thebesttv.github.io/tags/Polya-%E7%93%A6%E7%BD%90%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>[NOI 2005] 聪聪和可可</title>
    <link href="https://thebesttv.github.io/2018/02/13/NOI_2005_cchkk/"/>
    <id>https://thebesttv.github.io/2018/02/13/NOI_2005_cchkk/</id>
    <published>2018-02-13T08:21:00.000Z</published>
    <updated>2018-02-13T10:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个无向图，一只猫和一只老鼠在图上移动。在每个单位时间内：</p><ul><li>猫先移动一步，到达离老鼠最近的序号最小的点。如果还没抓到老鼠，再同样移动一步。若与老鼠相遇，则吃掉老鼠；</li><li>若老鼠还没被吃，则它能够向周围距离不超过 $1$ 的点（包括当前所在点）等概率地移动。</li></ul><p>已知猫和老鼠的起点，求出猫抓到老鼠的平均消耗时间。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>令 $f[i][j]$ 表示猫在 $i$ 点，老鼠在 $j$ 点时，猫抓老鼠的期望消耗时间，则<br>  $$ f[i][j] = \sum f[g[i][j]][k] / (p+1) $$<br>其中 $g[i][j]$ 表示猫在 $i$ 点，老鼠在 $j$ 点，猫将会走到哪里，$p$ 表示 $j$ 周围距离为 $1$ 的节点数。显然只要 $i,j$ 不变，$g[i][j]$ 不会改变。那么就可以预处理出来。</p><p>有一个很好的办法，先 Floyd 求出最短路，令 $to[i][j]$ 表示猫在 $i$ 点，老鼠在 $j$ 点，猫<strong>最多走一步</strong>将会走到哪里，则当且仅当 $d[i][k]=1$ 并且 $d[i][j] = d[i][k] + d[k][j] $ 时 $to[i][j]=k$ 。这样以来，$g$ 就可以轻松确定了。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,d[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> to[MAX][MAX]; <span class="comment">// to[i][j]: 从 i 到 j ，走一步能走到的最近点（序号最小）</span></span><br><span class="line">VR&lt;<span class="keyword">int</span>&gt; G[MAX];</span><br><span class="line"><span class="keyword">double</span> check_f[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> vis[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s==t) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">if</span>(vis[s][t]) <span class="keyword">return</span> check_f[s][t];</span><br><span class="line">  <span class="keyword">double</span> &amp;a=check_f[s][t]; vis[s][t]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(d[s][t]&lt;=<span class="number">2</span>) a=<span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v=to[to[s][t]][t]; a=f(v,t);</span><br><span class="line">    FOR(i,<span class="number">0</span>,G[t].size()) a+=f(v,G[t][i]);</span><br><span class="line">    a = a/(<span class="number">1</span>+G[t].size()) + <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  MST(d,<span class="number">0x3f</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">  FORR(i,<span class="number">1</span>,n) d[i][i]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> u,v;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">    d[u][v]=d[v][u]=<span class="number">1</span>;</span><br><span class="line">    G[u].push_back(v); G[v].push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Floyd</span></span><br><span class="line">  ROR(k,n,<span class="number">1</span>) FORR(i,<span class="number">1</span>,n) <span class="keyword">if</span>(d[i][k]&lt;INF) FORR(j,<span class="number">1</span>,n)</span><br><span class="line">    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">  <span class="comment">// init to</span></span><br><span class="line">  FORR(i,<span class="number">1</span>,n) FORR(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i][j]&lt;=<span class="number">1</span>) to[i][j]=j;</span><br><span class="line">    <span class="keyword">else</span> FORR(k,<span class="number">1</span>,n) <span class="keyword">if</span>(d[i][k]==<span class="number">1</span> &amp;&amp; d[i][j]==d[i][k]+d[k][j])&#123;</span><br><span class="line">      to[i][j]=k; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>,f(s,t));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个无向图，一只猫和一只老鼠在图上移动。在每个单位时间内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;猫先移动一步，到达离老鼠最近的序号最小的点。如果还没抓到老鼠，再同样移动一步。若与老鼠相遇，则吃掉老鼠；&lt;/li&gt;
&lt;li&gt;若老鼠还没被吃，则它能够向周围距离不超过 $1$ 的点（包括当前所在点）等概率地移动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;已知猫和老鼠的起点，求出猫抓到老鼠的平均消耗时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="最短路" scheme="https://thebesttv.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>狄利克雷卷积、莫比乌斯反演、杜教筛</title>
    <link href="https://thebesttv.github.io/2018/02/13/dirichlet_mu_dujiao_sieve/"/>
    <id>https://thebesttv.github.io/2018/02/13/dirichlet_mu_dujiao_sieve/</id>
    <published>2018-02-12T16:00:00.000Z</published>
    <updated>2019-08-04T14:34:17.718Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于狄利克雷卷积、莫比乌斯反演、杜教筛的学习笔记。</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数"></a>常见的积性函数</h2><p>除数函数 $\sigma_k = \sum_{d|n}d^k$ ，表示 $n$ 的约数的 $k$ 次方和<br>约数个数函数 $d(n) = \sigma_0(n) = \sum_{d|n}1$<br>约数和函数 $\sigma(n) = \sigma_1(n) = \sum_{d|n}d$<br>单位元 $\epsilon(n) = [n=1]$<br>$id(n)=n$<br>$I(n)=1$<br>莫比乌斯函数 $\mu(n)$<br>欧拉函数 $\varphi(n) = \sum_{i=1}^{n} [(i,n)=1]$ ，表示不大于 $n$ 且与 $n$ 互质的数的个数。当 $n&gt;2$ 时，$\varphi(n)$ 为偶数。有 $\varphi(n) = n \prod (1-1/p_i)$ 。<br>TODO<br>有<br>$$ n=\prod_{i=1} ^ {k} p_{i} ^ {a_i}, g(n) = \sum_{d|n} f(d) \implies g(n) = \prod_{i=1} ^ {k} \sum_{j=1} ^ {a_i} f(p_i ^ j) $$<br>可以通过一一对应的思想证明。</p><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>对于 $\forall f,g \in \mathbf I $ ，其狄利克雷卷积为：<br>$$ (f*g)(n) = \sum_{d|n} f(d) g \left( \frac{n}{d} \right) $$</p><p>狄利克雷卷积满足：</p><p>结合律： $\forall f, g, h \in \mathbf I, f * ( g * h ) = ( f * g ) * h $<br>交换律： $\forall f, g \in \mathbf I, f * g = g * f $<br>加法分配率： $\forall f, g, h \in \mathbf I, f * ( g + h ) = f * g + f * h $<br>存在单位元： $\forall f \in \mathbf I, \epsilon * f = f * \epsilon = f $<br>若 $f,g$ 为积性函数，则 $f*g$ 也为积性函数</p><h2 id="常见的卷积"><a href="#常见的卷积" class="headerlink" title="常见的卷积"></a>常见的卷积</h2><p>$ \mu * 1 = \epsilon \impliedby \sum_{d|n} \mu(d) = [n=1] $<br>$ \varphi * 1 = id \impliedby \sum_{d|n} \varphi(d) = n $<br>$ d = 1 * 1 $<br>$ \sigma = id * 1 $</p><h2 id="莫比乌斯反演的另一种证明"><a href="#莫比乌斯反演的另一种证明" class="headerlink" title="莫比乌斯反演的另一种证明"></a>莫比乌斯反演的另一种证明</h2><p>\begin{split}<br>F(n) &amp;= ( f * 1 )(n) \\<br>(F * \mu)(n) &amp;= (f * ( 1 * \mu ) )(n) \\<br>\end{split}<br>由于 $ 1 * \mu = \epsilon $ ，则<br>$$ (F * \mu)(n) = f(n) $$</p><p>有 $ \varphi * 1 = id \implies \varphi = id * \mu $ ，即<br>$$ \varphi(n) = \sum_{d|n} \mu(d) \cdot id\left(\frac{n}{d}\right) = n \sum_{d|n} \frac{\mu(d)}{d} \\<br>\frac{\varphi(n)}{n} = n \sum_{d|n} \frac{\mu(d)}{d} \\<br>$$</p><h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><h2 id="一个好玩的结论"><a href="#一个好玩的结论" class="headerlink" title="一个好玩的结论"></a>一个好玩的结论</h2><p>对于任意函数 $f$ ，有<br>$$ \sum_{i=1}^{n} \sum_{j=1}^{ \lfloor \frac{n}{i} \rfloor} f(i) = \sum_{i=1}^{n} \sum_{j=1}^{ \lfloor \frac{n}{i} \rfloor} f(j) $$</p><p>证明：<br>$$ 左边 = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor f(i) $$<br>也就是说每个 $f(i)$ 都被算了 $\lfloor n/i \rfloor$ 次。这样，只需证明右边每个 $f(j)$ 也被计算了 $\lfloor n/j \rfloor$ 次即可。<br>对于右边的每个 $f(j)$ ，当且仅当 $\lfloor n/i \rfloor \geq j$ 时会被计算到。则 $i\leq \lfloor n/j \rfloor$ ，$ i \in [1, \lfloor n/j \rfloor ]$ ，共有 $\lfloor n/j \rfloor$ 个，得证。</p><p>ps: 经 gr 大神指点，如果把得到的结果看成一张表的话，那么左边和右边就是一个横着计算，一个竖着计算。嗯仿佛这就是所谓“算两遍”。仿佛回想起冬令营那节昏昏欲睡的课</p><h2 id="杜教筛-1"><a href="#杜教筛-1" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>杜教筛是一种能够在 $O(n^{2/3})$ 的时间内求出积性函数前缀和的算法。它与线性筛配合，<strong>人为构造</strong>一个易于计算的卷积前缀和，在<strong>缩小了问题规模</strong>的基础上允许分块，使其能够通过记忆化搜索求解。</p><p>它通常适用于一种情况：对于函数 $f \in \mathbf I$ ，求出 $ S(n) = \sum_{i=1}^{n} f(i) $ ，其中 $n \geq 10^8$，无法通过线性筛求解。<br>人为构造一个函数 $ g \in \mathbf I $，且 $g(1) \neq 0$ ，对 $f$ 求卷积前缀和：<br>\begin{split}<br>\sum_{i=1}^{n} (f<em>g)(i) &amp;= \sum_{i=1}^{n} \sum_{d|i} g(d) f \left( \frac{i}{d} \right) \\<br>&amp;= \sum_{d=1}^{n} g(d) \sum_{d|i}^{ i \leq n } f \left( \frac{i}{d} \right) \\<br>&amp;= \sum_{d=1}^{n} g(d) \sum_{i=1}^{ \lfloor n/d \rfloor } f(i) \\<br>&amp;= \sum_{d=1}^{n} g(d) S\left( \lfloor n/d \rfloor \right) \\<br>\end{split}<br>再将 $d=1$ 时提出来，顺便改成 $i$ ，有<br>\begin{split}<br>\sum_{i=1}^{n} (f</em>g)(i) = g(1) S(n) + \sum_{i=2}^{n} g(i) S( \lfloor n/i \rfloor ) \\<br>\implies g(1) S(n) = \sum_{i=1}^{n} (f*g)(i) - \sum_{i=2}^{n} g(i) S( \lfloor n/i \rfloor ) \\<br>\end{split}</p><p>通过人为构造一个函数 $g$ ，使得能够快速求出 $\sum_{i=1}^{n} (f*g)(i)$ ，这样就可以通过记忆化搜索逐步减小子问题的规模，直到可以通过线性筛求解。</p><p>通常用线性筛预处理 $1:n^{2/3}$ 的前缀和，在子问题规模不超过 $n^{2/3}$ 时直接返回答案，其他情况分块，这样可达到最好时间复杂度 $O(n^{2/3})$ 。</p><h2 id="两个简单的应用"><a href="#两个简单的应用" class="headerlink" title="两个简单的应用"></a>两个简单的应用</h2><p>求 $\mu$ 的前缀和<br>由 $\mu<em>1=\epsilon$ ，令 $g(n)=1$ 带入上述公式，有<br>$$ S(n) = \sum_{i=1}^{n} \mu</em>1 - \sum_{i=2}^{n} S( \lfloor n/i \rfloor ) = 1 - \sum_{i=2}^{n} S( \lfloor n/i \rfloor ) $$</p><p>求 $\varphi$ 的前缀和<br>由 $\varphi*1=id$ ，令 $g(n)=1$ 带入上述公式，有<br>$$ S(n) = \sum_{i=1}^{n}i - \sum_{i=2}^{n} S( \lfloor n/i \rfloor ) = \frac{n(n+1)}{2} - \sum_{i=2}^{n} S( \lfloor n/i \rfloor ) $$</p><p>ps: 仿佛杜教筛=卷积前缀和+记忆化+线性筛+分块</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于狄利克雷卷积、莫比乌斯反演、杜教筛的学习笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="莫比乌斯反演" scheme="https://thebesttv.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="杜教筛" scheme="https://thebesttv.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
      <category term="TODO" scheme="https://thebesttv.github.io/tags/TODO/"/>
    
      <category term="学习笔记" scheme="https://thebesttv.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="狄利克雷卷积" scheme="https://thebesttv.github.io/tags/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[UVA 11637] Garbage Remembering Exam</title>
    <link href="https://thebesttv.github.io/2018/02/12/UVA_11637_Garbage_Remembering_Exam/"/>
    <id>https://thebesttv.github.io/2018/02/12/UVA_11637_Garbage_Remembering_Exam/</id>
    <published>2018-02-12T09:38:00.000Z</published>
    <updated>2018-02-12T10:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个长 $n$ 的环，其中所有元素有序。对这 $n$ 个环上的元素随机建立一条长 $n$ 的链。对于元素$a$和$b$，若它们在环上的距离和它们在链上的距离都不超过 $k$ ，则称$a$和$b$都是无效的。求平均有多少个无效的元素。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>正难则反，转化为求平均的有效元素，然后用 $n$ 减去它即可。</p><p>$$ ans = E \left(\sum 链上元素有效 \right) = \sum E(链上元素i有效) $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  A1 &lt;-  B1  i  B2  -&gt;  A2</span><br><span class="line">------|------x------|--------&gt;</span><br></pre></td></tr></table></figure><p>对于链上的第 i 个元素，其对应的环上元素的左右各有 $k$ 个不能靠近的元素，它们都要放到A1和A2组成的区间中，而剩下的 $n-2k-1$ 个元素则放入剩下的空位中。假设A1和A2共能放入x个元素，有<br>\begin{split}<br>  E(i) &amp;= \frac { A_{x}^{2k} \cdot A_{n-2k-1}^{n-2k-1} } {A_{n-1}^{n-1}} \\<br>       &amp;= \frac { x! \cdot (n-2k-1)! } { (x-2k)! \cdot (n-1)! } \\<br>\end{split}<br>而 $x$ 的计算比较简便，两边分别计数即可：<br>$$ x = max(i-k-1,0) + max(n-i-k,0) $$</p><p>但如果只是这样，每计算一个 $E(i)$ 就要花 $O(k)$ 的时间，总的复杂度会变成 $O(nk)$，需要优化对 $E(i)$ 的求解。<br>对于 $E(i)$ 的推到式，两边同取 $ln$ ，有<br>  $$ ln(E(i)) = ln(x!) - ln(x-2k)! + ln(n-2k-1)! - ln(n-1)! $$<br>这样一来，只需初始化 $ln(1:k)$ ，就可以实现 $O(1)$ 求 $E(i)$ 。<br>初始化时，有 $ ln(x!) = ln(x) + ln(x-1)! $ 。</p><p>ps: 还有一个要注意的坑点，当 $n=1$ 时，答案一定是 $0$ 。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100020</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> lf[MAX];  <span class="comment">// lf[i] = log(i!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//期望的线性性质 E(a+b) = E(a) + E(b)</span></span><br><span class="line"><span class="comment">// E( sum&#123;队列中的第i个单词是无效的期望&#125; ) = sum&#123; E(i) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  FOR(i,<span class="number">2</span>,MAX) lf[i] = lf[i<span class="number">-1</span>] + <span class="built_in">log</span>(i);</span><br><span class="line">  <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k) &amp;&amp; n)&#123;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) ans=<span class="number">0</span>; <span class="comment">//&lt;b&gt; &lt;/b&gt;</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      FORR(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = max(i<span class="number">-1</span>-k,<span class="number">0</span>) + max(n-i-k,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">2</span>*k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> t = lf[x] - lf[x<span class="number">-2</span>*k] + lf[n<span class="number">-1</span><span class="number">-2</span>*k] - lf[n<span class="number">-1</span>];</span><br><span class="line">        ans += <span class="built_in">exp</span>(t);  <span class="comment">// exp(t) = e^t</span></span><br><span class="line">      &#125;</span><br><span class="line">      ans = n-ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: %.4lf\n"</span>,++kase,ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个长 $n$ 的环，其中所有元素有序。对这 $n$ 个环上的元素随机建立一条长 $n$ 的链。对于元素$a$和$b$，若它们在环上的距离和它们在链上的距离都不超过 $k$ ，则称$a$和$b$都是无效的。求平均有多少个无效的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="期望的线性性质" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B%E7%9A%84%E7%BA%BF%E6%80%A7%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>[UVA 11605] Lights inside a 3d Grid</title>
    <link href="https://thebesttv.github.io/2018/02/12/UVA_11605_Lights_inside_a_3d_Grid/"/>
    <id>https://thebesttv.github.io/2018/02/12/UVA_11605_Lights_inside_a_3d_Grid/</id>
    <published>2018-02-12T08:39:00.000Z</published>
    <updated>2018-02-12T09:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个大小为 $ N \times M \times P $ 的三维网格，每格有一个灯，初始时所有灯关闭。进行 $K$ 次操作，每次随机选择两个格子（可以重合），将以这两格为对角顶点的长方体内的所有灯的状态取反。问最终量着的灯数量的期望。</p><a id="more"></a><h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><p>每个点都是独立的，不会受到周围点的影响。</p><p>$$ ans = E \left( \sum A_{i,j,k} \right) = \sum_{i,j,k} E(A_{i,j,k}) $$</p><p>只需求出每个点最终亮灯的期望即可。</p><p>设点 $A$ 被选择的概率为 $P(A)$，当且仅当 $A$ 被选择奇数次时亮灯，那么有<br>$$ E(A) = \sum_{i=1,3,5,\cdots } ^ { i \leq k } C_k^i , P(A)^i , (1-P(A))^{k-i} $$<br>可以看出这与二项式定理很像，但只有奇数项。<br>由<br>$$ ( P + (1 - P)) ^ k = \sum_{i=0}^{k} C_k^i , P^i , (1-P)^{k-i} $$<br>$$ - ( - P + (1 - P)) ^ k = - \sum_{i=0}^{k} C_k^i ,  (-1)^i , P^i , (1-P)^{k-i} $$<br>两式相加就消除了偶数项，就有<br>\begin{split}<br>  E(A) &amp;= \frac { (P(A)+(1-P(A)))^k - (-P(A)+(1-P(A)))^k } {2} \\<br>       &amp;= \frac {1 - (1 - 2P(A))^k } {2}<br>\end{split}<br>那么现在就只需算出 $P(A)$ 了。</p><p>因为每次选择的是一个长方体，对于每个长方体来说是等可能的，而对于每个点来说却是不等的。选择了一个矩形，等效于在X轴、Y轴、Z轴上分别选择三个区间。一个点 $A(x,y,z)$ 被选择，一定要保证 $x$ 被X轴上的区间覆盖到（$y$ 与 $z$ 亦然）。那么 $P(A_{x,y,z}) = P(x) \cdot P(y) \cdot P(z) $，其中 $P(x)$ 为在X轴上点$x$被覆盖到的可能。</p><p>现在只需求出 $P(x)$ 即可，$P(y)$ 和 $P(z)$ 同理。<br>考虑一维空间上的区间选择：<br>  $$ a – b – c $$<br>一共有 9 种等可能的选择方法，$P(a) = P(c) = \frac{5}{9}$, $P(b) = \frac{7}{9}$ 。<br>可以发现，对于选择区间的端点 $x_1,x_2$，有<br>\begin{split}<br>  P(x) &amp;= P(x_1 \leq x \cap x_2 \geq x) \cup P(x_2 \leq x \cap x_1 \geq x) \\<br>       &amp;= P(x_1 \leq x \cap x_2 \geq x) + P(x_2 \leq x \cap x_1 \geq x) - P( x_1 = x_2 = x)\\<br>       &amp;= 2 P(x_1 \leq x) \cdot P(x_2 \geq x) - P(x_1=x) \cdot P(x_2=x) \\<br>       &amp;= 2 \frac { x } { n } \cdot \frac { n - x + 1 } { n } - \frac {1}{n} \cdot \frac {1}{n} \\<br>       &amp;= \frac { 2x(n-x+1) - 1 } {n^2} \\<br>\end{split}<br>那么就可以求出答案了。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">P</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span>*x*(n-x+<span class="number">1</span>)<span class="number">-1</span>)/n/n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">  FORR(kase,<span class="number">1</span>,T)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">    <span class="keyword">double</span> px,py,pz,ans=<span class="number">0</span>;</span><br><span class="line">    FORR(x,<span class="number">1</span>,a)&#123;</span><br><span class="line">      px=P(x,a);</span><br><span class="line">      FORR(y,<span class="number">1</span>,b)&#123;</span><br><span class="line">        py=P(y,b);</span><br><span class="line">        FORR(z,<span class="number">1</span>,c)&#123;</span><br><span class="line">          pz=P(z,c);</span><br><span class="line">          <span class="keyword">double</span> p = px*py*pz;</span><br><span class="line">          ans += ( <span class="number">1</span> - <span class="built_in">pow</span>(<span class="number">1</span><span class="number">-2</span>*p,k) )/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>,kase,ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个大小为 $ N \times M \times P $ 的三维网格，每格有一个灯，初始时所有灯关闭。进行 $K$ 次操作，每次随机选择两个格子（可以重合），将以这两格为对角顶点的长方体内的所有灯的状态取反。问最终量着的灯数量的期望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概率" scheme="https://thebesttv.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="期望的线性性质" scheme="https://thebesttv.github.io/tags/%E6%9C%9F%E6%9C%9B%E7%9A%84%E7%BA%BF%E6%80%A7%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
</feed>
